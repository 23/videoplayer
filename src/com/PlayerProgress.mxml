<?xml version="1.0" encoding="utf-8"?>                                                                                                                                    
<mx:Canvas 
	xmlns:mx="http://www.adobe.com/2006/mxml"
	horizontalScrollPolicy="off" 
	verticalScrollPolicy="off"
	useHandCursor="true" 
	buttonMode="true" 
	height="32"
	top="2" 
	click="seekVideoTo((this.contentMouseX-5)/videoProgress.width*activeElement.getNumber('length'));" 
	>
	<!-- VideoProgress -->
	<mx:Canvas id="videoProgress" 
		top="9" 
		left="5" 
		right="10" 
		height="9" 
		borderColor="#999999" 
		borderStyle="solid" 
		borderThickness="1" 
	 	>
		<mx:Canvas id="videoBufferProgress" 
			x="0" 
			height="7" 
			backgroundColor="#DDDDDD" 
			/>
		<mx:Canvas id="videoPlayProgress" 
			x="0" 
			height="7" 
			backgroundColor="#999999" 
			/>
	</mx:Canvas>					

	<mx:Image id="progressHandle"
		x="{Math.min(videoPlayProgress.x+videoPlayProgress.width+5, videoPlayProgress.x+videoProgress.width)}"
		y="7"
		source="@Embed(source='assets/buttons/progress-handle.swf')"
		/>

	<!-- videoTime -->
	<mx:HBox id="videoTime" 
		right="7" 
		bottom="0"
		>
		<mx:Label id="videoTimeLabel" 
			selectable="false" 
			fontFamily="Helvetica, Arial" 
			fontSize="9" 
			height="12" 
			color="#333333"
			/>
	</mx:HBox>
	
	<mx:Script>
		<![CDATA[
			import mx.events.VideoEvent;
			import mx.controls.VideoDisplay;

			// Import props hash array from main application 
			import mx.core.Application;
			import com.philemonworks.flex.util.HashCollection;
			[bindable] private var props:HashCollection = mx.core.Application.application.props;
			[bindable] private var activeElement:HashCollection = mx.core.Application.application.activeElement;
			
			// Component-specific functions and event-handlers
			private function formatTime(time:int, totalTime:int = -1, join:String = ' / '):String {
				if (time<0) return("");
				if (totalTime>=0) {
					return(Math.floor(time/60).toString() +':'+ (time%60<10?'0':'') + Math.round(time%60).toString() + join + Math.floor(totalTime/60).toString() +':'+ (totalTime%60<10?'0':'') + Math.round(totalTime%60).toString());
				} else {
					return(Math.floor(time/60).toString() +':'+ (time%60<10?'0':'') + Math.round(time%60).toString());
				}
			}
            private function seekVideoTo(time:int):void {
            	if(!_targetVideo) return;
            	if(time>activeElement.getNumber('length')) return;
            	var approxBufferTime:Number = (_targetVideo.totalTime * (_targetVideo.bytesLoaded/_targetVideo.bytesTotal)) + activeElement.getNumber('start');
            	if(time>new Number(activeElement.get('start')) && time<approxBufferTime) {
            		_targetVideo.playheadTime = time-activeElement.getNumber('start');
            		if(!_targetVideo.playing) _targetVideo.play();
            	} else {
            		if ((props.get('streaming') as Boolean)) {
            			activeElement.put('start', time);
            			activeElement.put('skip', '1');
            			_targetVideo.stop();
            			_targetVideo.source = getFullVideoSource();
            			_targetVideo.play();
            		}
            	}
            }
            private function updateBuffer(e:Event):void {
            	if(!_targetVideo) return;
            	videoBufferProgress.x = activeElement.getNumber('start') / activeElement.getNumber('length') * videoProgress.width;
            	videoBufferProgress.width = _targetVideo.bytesLoaded/_targetVideo.bytesTotal*(videoProgress.width-videoBufferProgress.x);
            }
            private function updatePlay(e:Event):void {
            	if(!_targetVideo) return;
				videoPlayProgress.x = activeElement.getNumber('start') / activeElement.getNumber('length') * videoProgress.width;
				videoPlayProgress.width  = _targetVideo.playheadTime/_targetVideo.totalTime*(videoProgress.width-videoPlayProgress.x);
				videoTimeLabel.text = formatTime(_targetVideo.playheadTime + activeElement.getNumber('start'), activeElement.getNumber('length'));
            }

			private function getFullVideoSource():String {
				return(activeElement.getString('videoSource') + '?start=' + encodeURIComponent(activeElement.getString('start')) + '&skip=' + encodeURIComponent(activeElement.getString('skip')));
			}            
            
			// Which video display are we binding to? (and attach to events)
			private var _targetVideo:VideoDisplay;
			public function set targetVideo(v:VideoDisplay):void {
				_targetVideo = v;
				v.addEventListener(VideoEvent.PLAYHEAD_UPDATE, updatePlay);
				v.addEventListener(ProgressEvent.PROGRESS, updateBuffer);
			}
			public function get targetVideo():VideoDisplay {return(_targetVideo);}
		]]>
	</mx:Script>	
</mx:Canvas>
